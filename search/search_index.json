{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DSA Study Plan","text":"<p>Data Structures and Algorithms (DSA) is a fundamental concept in computer science that involves the study and implementation of various ways to organize and manipulate data in a computer program. It covers the implementation and analysis of data structures such as arrays, linked lists, stacks, queues, trees, and graphs, as well as the design and analysis of algorithms for sorting, searching, and other operations on these data structures. Understanding DSA is essential for building efficient and scalable software systems, as it allows developers to make  informed decisions about which data structures and algorithms to use for a given problem, and how to optimize their performance.</p> <p>This document is ment for:</p> <ol> <li>Develop a strong understanding of fundamental data structures and algorithms, such as arrays, linked lists, stacks, queues, trees, and graphs.</li> <li>Learn how to analyze the time and space complexity of algorithms, and understand how to optimize them for better performance.</li> <li>Understand how to implement common algorithms for sorting, searching, and other operations on data structures.</li> <li>Learn how to apply data structures and algorithms to solve real-world problems, such as searching large datasets, optimizing network routing, and solving computational problems in science and engineering.</li> <li>Document my learning process by creating this website to demonstrate my understanding of DSA concepts and my ability to apply them to solve problems.</li> </ol>"},{"location":"cpp_Input_and_Output/","title":"C++ Input & Output","text":""},{"location":"cpp_Input_and_Output/#introduction","title":"Introduction","text":"<p>In C++, basic input and output can be achieved using the standard input/output library, which includes the following function:</p> <ul> <li><code>cin</code> (standard input) - reads input from the keyboard.</li> <li><code>cout</code> (standard output) - writes output to the screen.</li> <li><code>cerr</code> (standard error) - writes error messages to the screen.</li> </ul>"},{"location":"cpp_Input_and_Output/#cpp-output","title":"cpp Output","text":"<p>In C++, <code>cout</code> sends formatted output to standard output devices, such as the screen. We use the <code>cout</code> object along with the <code>&lt;&lt;</code> operator for displaying output.</p> <p>Example 1.1.1:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n// prints the string enclosed in double quotes\ncout &lt;&lt; \"Hello World!\";\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>Hello World!\n</code></pre> <p>Note: if we don't include the <code>using namespace std;</code> statement, we need to use <code>std::cout</code> instead of <code>cout</code>. This is the preferred method as using the <code>std</code> namespace can create potential problems.</p> <p>To print the numbers and character variables, we use the same <code>cout</code> object but without using quotation marks.</p> <p>Example 1.1.2:</p> <pre><code>#include &lt;iostream&gt;\nint main() {\nint num1 = 40;\ndouble num2 = 956.280;\nchar ch = 'D';\nstd::cout &lt;&lt; num1 &lt;&lt; endl;  // print integer\nstd::cout &lt;&lt; num2 &lt;&lt; endl;  // print double\nstd::cout &lt;&lt; \"character: \" &lt;&lt; ch &lt;&lt; endl;  // print character\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>40\n956.280\ncharacter: D\n</code></pre> <p>Notes: - The <code>endl</code> manipulator is used to insert a new line. That's why each output is displayed in a new line. - The <code>&lt;&lt;</code> operator can be used more than once if we want to print different variables, strings and so on in a single statement.</p>"},{"location":"cpp_Input_and_Output/#cpp-input","title":"cpp Input","text":"<p>In C++, <code>cin</code> takes formatted input from standard input devices such as the keyboard. We use the <code>cin</code> object along with the <code>&gt;&gt;</code> operator for taking input.</p> <p>Example 1.1.3:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main() {\nint num;\ncout &lt;&lt; \"Enter an integer: \";\ncin &gt;&gt; num;  // Taking input\ncout &lt;&lt; \"The number is: \" &lt;&lt; num;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>Enter an integer: 40\nThe number is: 40\n</code></pre> <p>In the program we used <code>cin &gt;&gt; num;</code> to take input from the user. The input is stored in the variable <code>num</code>. We then use the <code>&gt;&gt;</code> operator with <code>cin</code> to take input.</p>"},{"location":"cpp_Input_and_Output/#taking-multiple-inputs","title":"Taking Multiple Inputs","text":"<p>Example 1.1.4:</p> <pre><code>#include &lt;iostream&gt;\nint main() {\nchar a;\nint num;\nstd::cout &lt;&lt; \"Enter a character and an integer: \";\nstd::cin &gt;&gt; a &gt;&gt; num;\nstd::cout &lt;&lt; \"Character: \" &lt;&lt; a &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Number: \" &lt;&lt; num;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>Enter a character and an integer: A\n29\nCharacter: A\nNumber: 29\n</code></pre>"},{"location":"cpp_Input_and_Output/#cpp-files-io","title":"cpp Files I/O","text":"<p>C++ provides a standard library called <code>fstream</code> (file stream) that contains classes for working with files.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n</code></pre> <p>There are three classes included in the <code>fstream</code> library, which are used to create, write or read files:</p> Class Description <code>ofstream</code> Creates and writes to files <code>ifstream</code> Reads from files <code>fstream</code> A combination of <code>ofstream</code> and <code>ifstream</code>: creates, reads, and writes to files"},{"location":"cpp_Input_and_Output/#create-and-write-to-a-file","title":"Create and Write to a File","text":"<p>To create a new file or overwrite an existing file, you can use the <code>ofstream</code> class.</p> <p>Syntax:</p> <pre><code>#include &lt;fstream&gt;\n...\nofstream outfile;\noutfile.open(\"filename.txt\")\n</code></pre> <p>This creates a new file named \"filename.txt\" or overwrites an existing file with that name. You can then use the <code>&lt;&lt;</code> operator or the <code>write()</code> method to write data to the file.</p> <p>Example 1.1.5:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nint main(){\n// Create an ofstream object\nstd::ofstream outputFile(\"output.txt\");\n// Write data to the file\noutputFile &lt;&lt; \"Writing this text to the file\" &lt;&lt; std::endl;\noutputFile &lt;&lt; \"This is another line of text\" &lt;&lt; std::endl;\n// Close the file\noutputFile.close();\nstd::cout &lt;&lt; \"Data has been written to the file\" &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <p>This code:</p> <ul> <li>Creates an object of the <code>ofstream</code> class called <code>outputFile</code>, wich is used to open file called \"output.txt\" in the current directory.</li> <li>The code then uses the <code>outputFile</code> object to write some text to the file, and then closes the file.</li> </ul>"},{"location":"cpp_Input_and_Output/#read-a-file","title":"Read a File","text":"<p>To read data from an existing file, you can use the <code>ifstream</code> class.</p> <p>Syntax:</p> <pre><code>#include &lt;fstream&gt;\n...\nifstream infile;\ninfile.open(\"filename.txt\")\n</code></pre> <p>You can then use the <code>&gt;&gt;</code> operator or the <code>read()</code> method to read data from the file.</p> <p>Once you are done working with a file, you should close it using the <code>close()</code> method. This releases any resources that were associated with the file and ensures that any changes you made to the file are saved.</p> <p>It's also worth mentioning that you can check if the file is open or not by checking the <code>is_open()</code> method on the file stream variable.</p> <pre><code>if(outfile.is_open()) {\n// file is open and ready for operations\n}\n</code></pre> <p>You can also use <code>ios::app</code> flag to open a file in append mode, wich allows you to add data to the end of an existing file without overwriting it.</p> <p>Example 1.1.6:</p> <p>First, create the file \"input.txt\" and place your input like this:</p> <pre><code>This is string\nC\n23\n723.8\n</code></pre> <p>Then we write our program:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\nint main(){\n// Create an ifstream object\nstd::ifstream inputFile(\"input.txt\");\n// Check if the file could be opened\nif (!inputFile) {\nstd::cout &lt;&lt; \"Error opening file\" &lt;&lt; std::endl;\nreturn 1;\n}\n// Read data from the file\nstd::string line;\nwhile (std::getline(inputFile, line)) {\nstd::cout &lt;&lt; line &lt;&lt; std::endl;\n}\n// Close the file\ninputFile.close();\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>This is string\nC\n23\n723.8\n</code></pre> <p>This code:</p> <ul> <li>Creates an object of the <code>ifstream</code> class called <code>inputFile</code>, which is used to open a file called \"input.txt\" in the current directory.</li> <li>The code then uses an \"if\" statement to check if the file could be opened successfully.<ul> <li>If the file could not be opened, the code prints an error message.</li> </ul> </li> <li>The code then uses a while loop to read each line of the file using the <code>getline</code> function and the <code>inputFile</code> object, and it prints each line on the screen.</li> <li>Finally, the code closes the file.</li> </ul> <p>Note: Notice that we included a library named <code>&lt;string&gt;</code> wich is necessary for the <code>getline</code> function that we used in our code.</p> <p>Working with files in C++ can be a bit more complex than working with simple variables and data structures, but it provides a powerful way to store and retrieve data permanently.</p> <p>Example 1.1.7:</p> <p>First, create the file \"Files\\inputFile.txt\" and place your input like this:</p> <pre><code>6\n21.983\nH\n</code></pre> <p>Then we write our program:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nint main(){\n// Create ifstream and ofstream objects\nstd::ifstream inputFile(\"Files\\\\inputFile.txt\");\nstd::ofstream outputFile(\"Files\\\\outputFile.txt\");\nint x;\ndouble y;\nchar z;\noutputFile &lt;&lt; \"Input Section:\" &lt;&lt; std::endl;\noutputFile &lt;&lt; \"Enter an int value: \";\ninputFile &gt;&gt; x;\noutputFile &lt;&lt; x &lt;&lt; std::endl;\noutputFile &lt;&lt; \"Enter a double value: \";\ninputFile &gt;&gt; y;\noutputFile &lt;&lt; y &lt;&lt; std::endl;\noutputFile &lt;&lt; \"Enter a character: \";\ninputFile &gt;&gt; z;\noutputFile &lt;&lt; z &lt;&lt; std::endl;\noutputFile &lt;&lt; \"-------------------------------------\" &lt;&lt; std::endl;\noutputFile &lt;&lt; \"Output Section:\" &lt;&lt; std::endl;\noutputFile &lt;&lt; \"int value is: \" &lt;&lt; x &lt;&lt; std::endl;\noutputFile &lt;&lt; \"double value is: \" &lt;&lt; y &lt;&lt; std::endl;\noutputFile &lt;&lt; \"character value is: \" &lt;&lt; z &lt;&lt; std::endl;\noutputFile &lt;&lt; \"-------------------------------------\" &lt;&lt; std::endl;\n// Close the files \ninputFile.close(); outputFile.close();\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>Input Section:\nEnter an int value: 6\nEnter a double value: 21.983\nEnter a character: H\n-------------------------------------\nOutput Section:\nint value is: 6\ndouble value is: 21.983\ncharacter value is: H\n-------------------------------------\n</code></pre> <p>This code is a basic example of reading and writing data to and from files in C++. </p> <p>The code:</p> <ul> <li>Includes two libraries, <code>iostream</code> and <code>fstream</code>, which are used for input/output operations.</li> <li>In the <code>main</code> function, two objects, <code>inputFile</code> and <code>outputFile</code>, are created using the <code>ifstream</code> and <code>ofstream</code> classes respectively. These objects are used to open two files, <code>inputFile.txt</code> and <code>outputFile.txt</code>, that are located in a directory called \"Files\".</li> <li>The code then declares three variables, <code>x</code>, <code>y</code>, and <code>z</code>, which are used to store the input data read from the input file.</li> <li>The <code>outputFile</code> object is then used to write some text to the output file, including prompts for the user to enter an integer, double, and character, respectively.</li> <li>The <code>inputFile</code> object is then used to read these values from the input file, which are then written to the output file using the <code>outputFile</code> object.</li> <li>Finally, the code closes both files and return 0 to indicate successful execution.</li> </ul> <p>Note: That you need to create the <code>inputFile.txt</code> with the necessary input before running your code.</p>"},{"location":"cpp_array/","title":"C++ Arrays","text":""},{"location":"cpp_array/#introduction","title":"Introduction","text":"<p>An array is a collection of elements of the same data type, stored in contiguous memory locations. Arrays are used to store multiple values of the same type in a single variable.</p>"},{"location":"cpp_array/#cpp-array-declaration","title":"cpp Array Declaration","text":"<p>Syntax:</p> <pre><code>dataType arrayName[arraySize];\n</code></pre> <p>Example 1.4.1:</p> <pre><code>int x[6];\n</code></pre> <p>Here,</p> <ul> <li><code>int</code> - type of element to be stored.</li> <li><code>x</code> - name of the array.</li> <li><code>6</code> - size of the array.</li> </ul>"},{"location":"cpp_array/#access-elements-in-cpp-array","title":"Access Elements in cpp Array","text":"<p>In C++, each element in an array is associated with a number. The number is known as an array index. We can access elements of an array by using those indices.</p> <p>Syntax:</p> <pre><code>// syntax to access array elements\narray[index];\n</code></pre> <p>Consider the array <code>x</code> we have seen above:</p> <p> Array's Index</p> <p>Few things to remember</p> <ul> <li>The array indices start with <code>0</code>. Meaning <code>x[0]</code> is the first element stored at index <code>0</code>.</li> <li>If the size of an array is <code>n</code>, the last element is stored at index <code>(n-1)</code>. In this example, <code>x[5]</code> is the last element.</li> <li>Elements of an array have consecutive addresses. For example, suppose the starting address of <code>x[0]</code> is 2120d. Then, the address of the next element <code>x[1]</code> will be 2124d, the address of <code>x[2]</code> will be 2128d and so on.</li> </ul> <p>Here, the size of each element has increased by 4. This is because the size of <code>int</code> is 4 bytes.</p> <p>Example 1.5.1:</p> <pre><code>#include &lt;iostream&gt;\nint main(){\n// Declare an array of size 5\nint myArray[5];\n// Assign values to the array\nmyArray[0] = 1;\nmyArray[1] = 2;\nmyArray[2] = 3;\nmyArray[3] = 4;\nmyArray[4] = 5;\n// Print the elements of the array\nstd::cout &lt;&lt; myArray[0] &lt;&lt; \" \" &lt;&lt; myArray[1] &lt;&lt; \" \" &lt;&lt; myArray[2] &lt;&lt; \" \" &lt;&lt; myArray[3] &lt;&lt; \" \" &lt;&lt; myArray[4] &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>1 2 3 4 5\n</code></pre> <p>In this code:</p> <ul> <li>An array called <code>myArray</code> is declared with a size of <code>5</code>.</li> <li>Then, values are assigned to each element of the array using the array index.</li> <li>Finally, a <code>for</code> loop is used to print the values of the array.</li> </ul>"},{"location":"cpp_array/#cpp-array-initialization","title":"cpp Array Initialization","text":"<p>In C++, it's possible to initialize an array during declaration.</p> <p>Syntax:</p> <pre><code>// declare and initialize an array\ndataType arrayName[arraySize] = {element1, element2, ....};\n</code></pre> <p> Array initialization</p> <p>Another method to initialize array is during declaration:</p> <pre><code>dataType arrayName[] = {element1, element2, ....};\n</code></pre> <p>Here, we have not mentioned the size of the array. In such cases, the compiler automatically computes the size.</p> <p>Example 1.5.2:</p> <pre><code>#include &lt;iostream&gt;\nint main(){\n// Declare and initialize an array\nint myArray[] = {1, 2, 3, 4, 5};\n// Print the elements of the array\nstd::cout &lt;&lt; myArray[0] &lt;&lt; \" \" &lt;&lt; myArray[1] &lt;&lt; \" \" &lt;&lt; myArray[2] &lt;&lt; \" \" &lt;&lt; myArray[3] &lt;&lt; \" \" &lt;&lt; myArray[4] &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>1 2 3 4 5\n</code></pre> <p>This code is the same as the one before, only in here we used the <code>{}</code> notation to initialize an array with a set of values while declaring it.</p>"},{"location":"cpp_array/#cpp-array-with-empty-members","title":"cpp Array With Empty Members","text":"<p>In C++, if an array has a size of <code>n</code>, we can store up to <code>n</code> number of elements in the array. However, what will happen if we store less than <code>n</code> number of elements?</p> <p>In such cases, the compiler assigns random values to the remaining places.</p> <p>Oftentimes, this random value is simply <code>0</code>.</p> <p> Array padding empty members</p>"},{"location":"cpp_array/#cpp-array-out-of-bounds","title":"cpp Array Out of Bounds","text":"<p>If we declare an array of size <code>10</code>, then the array will contain elements from index <code>0</code> to <code>9</code>.</p> <p>However, if we try to access the element at index <code>10</code> or more than <code>10</code>, it will result in an \"Undefined Behavior\".</p>"},{"location":"cpp_conditional_statements/","title":"C++ Conditional Statements","text":""},{"location":"cpp_conditional_statements/#introduction","title":"Introduction","text":"<p>Conditional statements in C++ allow you to control the flow of a program based on certain conditions. The basic for of a conditional statement is an <code>if</code> statement. We use the <code>if</code> statement to run a block of code only when a certain condition is met.</p> <p>There are three forms of <code>if...else</code> statements in C++.</p> <ol> <li><code>if</code> Statement.</li> <li><code>if...else</code> Statement.</li> <li><code>if...else if...else</code> Statement.</li> </ol>"},{"location":"cpp_conditional_statements/#cpp-if-statement","title":"cpp if Statement","text":"<p>Syntax:</p> <pre><code>if (condition) {\n// body of if statement\n}\n</code></pre> <p>The <code>condition</code> is a Boolean expression that is evaluated to either true or false.</p> <ul> <li>If the <code>condition</code> evaluates to <code>true</code>, the code inside the body of <code>if</code> is executed.</li> <li>If the <code>condition</code> evaluates to <code>false</code>, the code inside the body of <code>if</code> is skipped.</li> </ul>"},{"location":"cpp_conditional_statements/#cpp-ifelse-statement","title":"cpp if...else Statement","text":"<p>Syntax:</p> <pre><code>if (condition) {\n// block of code if condition is true\n}\nelse {\n// block of code if condition is false\n}\n</code></pre> <p>The <code>if...else</code> allows you to specify code that should be executed if the condition is false.</p> <p>If the <code>condition</code> evaluates to <code>true</code>:</p> <ul> <li>the code inside the body of <code>if</code> is executed.</li> <li>the code inside the body of <code>else</code> is skipped from execution.</li> </ul> <p>If the <code>condition</code> evaluates to <code>false</code>:</p> <ul> <li>the code inside the body of <code>if</code> is skipped from execution.</li> <li>the code inside the body of <code>else</code> is executed.</li> </ul>"},{"location":"cpp_conditional_statements/#cpp-ifelse-ifelse-statement","title":"cpp if...else if...else Statement","text":"<p>Syntax:</p> <pre><code>if (condition1) {\n// code block 1\n}\nelse if (condition2) {\n// code block 2\n}\nelse {\n// code block 3\n}\n</code></pre> <p>Here,</p> <ul> <li>If <code>condition1</code> evaluates to <code>true</code>, the <code>code block 1</code> is executed.</li> <li>If <code>condition1</code> evaluates to <code>false</code>, then <code>condition2</code> is evaluated.</li> <li>If <code>condition2</code> evaluates to <code>true</code>, the <code>code block 2</code> is executed.</li> <li>If <code>condition2</code> evaluates to <code>false</code>, the <code>code block 3</code> is executed.</li> </ul>"},{"location":"cpp_conditional_statements/#cpp-nested-ifelse","title":"cpp Nested if...else","text":"<p>Syntax:</p> <pre><code>// outer if statement\nif (condition1) {\n// statements\n// inner if statement\nif (condition2) {\n// statements\n}\n}\n</code></pre> <p>Here,</p> <ul> <li>If <code>condition1</code> evaluates to <code>true</code>, the statements inside the outer if will be executed and the <code>condition2</code> will be evaluated.</li> <li>If <code>condition2</code> evaluates to <code>true</code>, the statements inside the inner if will be executed (Both outer and inner statements were executed).</li> <li>If <code>condition2</code> evaluates to <code>false</code>, then the block will be skipped (Only outer statement were executed).</li> <li>If <code>condition1</code> evaluates to <code>false</code>, then the block will be skipped (No statement will be executed).</li> </ul>"},{"location":"cpp_conditional_statements/#ternary-operator","title":"Ternary Operator","text":"<p>C++ also provide a ternary operator <code>? :</code> which is a shorthand for <code>if...else</code> statement and it is used to make the code more readable.</p> <p>Syntax:</p> <pre><code>variable = (condition) ? value1 : value2;\n</code></pre> <p>The above line of code can be read as \"if <code>condition</code> is <code>true</code> then assign <code>value1</code> to variable else assign <code>value2</code> to variable.\"</p> <p>Example 1.3.1:</p> <pre><code>#include &lt;iostream&gt;\nint main(){\nint a = 5;\nint b = 10;\nint c;\nc = (a &gt; b) ? a : b;\nstd::cout &lt;&lt; \"c: \" &lt;&lt; c &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>c: 10\n</code></pre> <p>In this code:</p> <ul> <li>The program will compare the value of <code>a</code> and <code>b</code>.</li> <li>If the value of <code>a</code> is greater than <code>b</code>, then <code>c</code> will be assigned the value of <code>a</code>.</li> <li>Otherwise <code>c</code> will be assigned the value of <code>b</code>.</li> </ul> <p>Note: Ternary operator should be used with caution, as it can make the code harder to read and understand if overused or used in complex expressions.</p> <p>Conditional statements are fundamental building block of many programs and they allow you to create more complex logic and decision making in your code.</p>"},{"location":"cpp_data_types/","title":"C++ Data Types","text":""},{"location":"cpp_data_types/#introduction","title":"Introduction","text":"<p>In C++, data types are used to define the type of a variable, which determines the size and layout of the variable's memory, as well as the set of operations that can be performed on it.</p>"},{"location":"cpp_data_types/#cpp-fundamental-data-types","title":"cpp Fundamental Data Types","text":"<p>The table below shows the fundamental data types, their meaning, and their sizes (in bytes):</p> Data Types Meaning Size (in Bytes) <code>int</code> Integer 2 or 4 <code>float</code> Floating-point 4 <code>double</code> Double Floating-point 8 <code>char</code> Character 1 <code>wchar_t</code> Wide Character 2 <code>bool</code> Boolean 1 <code>void</code> Empty 0"},{"location":"cpp_data_types/#cpp-type-modifiers","title":"cpp Type Modifiers","text":"<p>We can further modify some of the fundamental data types by using types modifiers.</p> <p>There are 4 types modifiers in C++. These are:</p> <ol> <li><code>signed</code></li> <li><code>unsigned</code></li> <li><code>short</code></li> <li><code>long</code></li> </ol> <p>We can modify the following types with the above modifiers:</p> <ul> <li><code>int</code></li> <li><code>double</code></li> <li><code>char</code></li> </ul>"},{"location":"cpp_data_types/#cpp-modifiers-data-types-list","title":"cpp Modifiers Data Types List","text":"Data Type Size (in Bytes) Meaning <code>signed int</code> 4 used for integers (equivalent to int) <code>unsigned int</code> 4 can only store positive integers <code>short</code> 2 used for small integers (range -32768 to 32767) <code>unsigned short</code> 2 used for small integers (range 0 to 65,535) <code>long</code> at least 4 used for large integers (equivalent to long int) <code>unsigned long</code> 4 used for large positive integers or 0 (equivalent to unsigned long int) <code>long long</code> 8 used for very large integers (equivalent to long long int) <code>unsigned long long</code> 8 used for very large integers or 0 (equivalent to unsigned long long int) <code>long double</code> 12 used for large floating-point numbers <code>singed char</code> 1 used for character (guaranteed range -127 to 127) <code>unsigned char</code> 1 used for characters (range 0 to 255) <p>Let's see a few examples:</p> <p>Example 1.2.1:</p> <pre><code>long b = 4523232;\nlong int c = 2345342;\nlong double d = 233434.56343;\nshort d = 3434233; // Error! out of range\nunsigned int a = -5;    // Error! can only store positive numbers or 0\n</code></pre>"},{"location":"cpp_data_types/#auto-specifier","title":"Auto specifier","text":"<p>The <code>auto</code> specifier is a way of detecting the data type base on assignment value.</p> <p>Example 1.2.2:</p> <pre><code>auto i = 5;   // causes i to be of type int\n// and\nauto j = 5.0; // causes j to be of type double.\n</code></pre>"},{"location":"cpp_data_types/#derived-data-types","title":"Derived Data Types","text":"<ul> <li>arrays.</li> <li>pointers.</li> <li>function types.</li> <li>structures.</li> </ul>"},{"location":"cpp_for_loop/","title":"C++ For Loop","text":"<p>Quick links to navigate: - [[#Introduction]]     - [[#cpp for Loop]]     - [[#Ranged Based for Loop]]     - [[#cpp Infinite for Loop]]</p>"},{"location":"cpp_for_loop/#introduction","title":"Introduction","text":"<p>In C++, loops are a control flow statements that allows you to execute a block of code repeatedly for a given number of iterations.</p>"},{"location":"cpp_for_loop/#cpp-for-loop","title":"cpp for Loop","text":"<p>Syntax:</p> <pre><code>for (initialization; condition; increment/decrement) {\n// code to be executed\n}\n</code></pre> <ul> <li>The <code>initialization</code> statement is executed only once, before the loop starts. It is used to initialize the loop control variable.</li> <li>The <code>condition</code> is a boolean expression that is evaluated before each iteration of the loop.<ul> <li>If the condition is true, the loop continues to execute.</li> <li>If the condition is false, the loop exits.</li> </ul> </li> <li>The <code>increment/decrement</code> statement is executed after each iteration of the loop. It is used to update the loop control variable.</li> </ul> <p> For Loop Statement Flowchart</p> <p>Example 1.6.1:</p> <pre><code>for (int i = 1; i &lt;= 10; i++) {\nstd::cout &lt;&lt; i &lt;&lt; \" \";\n}\n</code></pre> <p>Output:</p> <pre><code>1 2 3 4 5 6 7 8 9 10\n</code></pre> <p>In this code:</p> <ul> <li>The loop starts with the initialization statement <code>int i = 1</code>, which initializes the loop control variable <code>i</code> to <code>1</code>.</li> <li>The condition <code>i &lt;= 10</code> is checked before each iteration of the loop. As long as <code>i</code> is less than equal to <code>10</code>, the loop continues to execute.</li> <li>The increment statement <code>i++</code> is executed after each iteration of the loop, which increments the value of <code>i</code> by <code>1</code>.</li> </ul>"},{"location":"cpp_for_loop/#ranged-based-for-loop","title":"Ranged Based for Loop","text":"<p>The <code>ranged-based for loop</code> is  a new feature in C++11 that allows you to iterate over elements in an array or container with a simple and readable syntax. It uses a range-based expression to define the elements that the loop will operate on.</p> <p>Syntax:</p> <pre><code>for (element : collection) {\n// statements\n}\n</code></pre> <ul> <li><code>element</code> is a variable that will hold each element in the collection.</li> <li><code>collection</code> is the array or container to iterated.</li> </ul> <p>Example 1.6.2:</p> <pre><code>#include &lt;iostream&gt;\nint main() {\nint arr[] = {1, 2, 3, 4, 5};\nfor (int i : arr) {\nstd::cout &lt;&lt; i &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>1 2 3 4 5\n</code></pre> <p>In this code:</p> <ul> <li>The ranged-base <code>for</code> loop is used to iterate over the elements in the <code>arr</code> array.</li> <li>The variable <code>i</code> is declared inside the loop to hold each element.</li> <li>The body of the loop prints out each element in the array.</li> </ul>"},{"location":"cpp_for_loop/#cpp-infinite-for-loop","title":"cpp Infinite for Loop","text":"<p>If the <code>condition</code> in a <code>for</code> loop is always <code>true</code>, it runs forever (until memory is full).</p> <p>Syntax:</p> <pre><code>// infinite for loop\nfor (true) {\n// block of code\n}\n</code></pre>"},{"location":"cpp_functions/","title":"C++ Functions","text":""},{"location":"cpp_functions/#introduction","title":"Introduction","text":"<p>A function in C++ is a self-contained block of code that performs a specific task. Functions can take input parameters, perform some operations, and return an output. Functions can also be reused multiple times throughout a program, making the code more organized an easier to maintain.</p> <p>There are two types of functions:</p> <ol> <li>Standard Library Functions: Predefined in C++.</li> <li>User-defined Functions: created by users.</li> </ol>"},{"location":"cpp_functions/#cpp-function-declaration","title":"cpp Function Declaration","text":"<p>Syntax:</p> <pre><code>returnType functionName (parameter1, parameter2, ...) {\n// function body\n}\n</code></pre> <p>Example 1.8.1:</p> <pre><code>#include &lt;iostream&gt;\nint addNumbers(int x, int y) {\nint result = x + y;\nreturn result;\n}\nint main() {\nint a = 10;\nint b = 20;\nint sum = addNumbers(a, b);\nstd::cout &lt;&lt; \"The sum of \" &lt;&lt; a &lt;&lt; \" and \" &lt;&lt; b &lt;&lt; \" is: \" &lt;&lt; sum &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>The sum of 10 and 20 is: 30\n</code></pre> <p>In this code:</p> <ul> <li>The function <code>addNumbers</code> takes two <code>int</code> parameters <code>x</code> and <code>y</code>.</li> <li>The function then adds them together and returns the result.</li> <li>In the <code>main</code> function, the values of <code>a</code> and <code>b</code> are passed to the <code>addNumbers</code> function.</li> <li>The result is stored in the variable <code>sum</code>.</li> <li>The <code>sum</code> is then printed to the console.</li> </ul>"},{"location":"cpp_functions/#function-prototype","title":"Function Prototype","text":"<p>In C++, the code of function declaration should be before the function call. However, if we want to define a function after the function call, we need to use the function prototype.</p> <p>Syntax:</p> <pre><code>// function prototype\nreturnType functionName(dataType1, dataType2, ...);\nint main() {\n// calling the function before declaration\nfunctionName(dataType1, dataType2, ...);\nreturn 0;\n}\n// function definition\nreturnType functionName(dataType1, dataType2, ...) {\n... .. ...\n... .. ...\n}\n</code></pre> <p>The prototype provides the compiler with information about the function name and its parameters. That's why we can use the code to call a function before the function has been defined.</p>"},{"location":"cpp_functions/#passing-by-value-and-passing-by-reference","title":"Passing by value and Passing by reference","text":"<p>In C++, when a function is called, you can pass parameters to the function in two ways:</p> <ol> <li>by value.</li> <li>by reference.</li> </ol> <p>Passing by value means that a copy of the actual parameter is made, and the function operates on the copy. Changes made to the parameter within the function are not reflected in the calling code.</p> <p>Passing by reference means that the function operates directly on the original parameter. Changes made to the parameter within the function are reflected in the calling code.</p> <p>Example 1.8.2:</p> <pre><code>#include &lt;iostream&gt;\nvoid addOne (int x) {\nx++;\n}\nint main() {\nint num = 10;\naddOne(num);\nstd::cout &lt;&lt; \"The value of num is: \" &lt;&lt; num &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>The value of num is: 10\n</code></pre> <p>In this code:</p> <ul> <li>The function <code>addOne</code> takes an <code>int</code> parameter <code>x</code> and increments it by <code>1</code>.</li> <li>In the <code>main</code> function, the value of <code>num</code> is passed to the <code>addOne</code> function.</li> <li>However, after the function call, the value of <code>num</code> remains unchanged, as the function operates on a copy of <code>num</code>.</li> </ul> <p>Example 1.8.3:</p> <pre><code>#include &lt;iostream&gt;\nvoid addOne (int &amp;x) {\nx++;\n}\nint main() {\nint num = 10;\naddOne(num);\nstd::cout &lt;&lt; \"The value of num is: \" &lt;&lt; num &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>11\n</code></pre> <p>In this code:</p> <ul> <li>The function <code>addOne</code> takes an <code>int</code> reference parameter <code>x</code> and increments it by <code>1</code>.</li> <li>In the <code>main</code> function, the value of <code>num</code> is passed to the <code>addOne</code> function.</li> <li>After the function call, the value of <code>num</code> is incremented by <code>1</code>, as the function operates directly on <code>num</code>.</li> </ul> <p>Example 1.8.4:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n/* Apply equation to parameters passed by value\n * Z = 10*X + 20*Y\n */\nint FuncVal(int x,int y)\n{\nx *= 10;\ny *= 20;\nint z = x + y;\nreturn z;\n}\n/* Apply equation to parameters passed by reference\n * Z = 10*X + 20*Y\n */\nint FuncRef(int* x,int* y)\n{\n(*x) *= 10;\n(*y) *= 20;\nint z = (*x) + (*y);\nreturn z;\n}\nint main(){\nint x1, x2, y1, y2;\ncout &lt;&lt; \"Enter x1 value: \";\ncin &gt;&gt; x1;\ncout &lt;&lt; endl;\ncout &lt;&lt; \"Enter y1 value: \";\ncin &gt;&gt; y1;\ncout &lt;&lt; endl;\ncout &lt;&lt; \"Enter x2 value: \";\ncin &gt;&gt; x2;\ncout &lt;&lt; endl;\ncout &lt;&lt; \"Enter y2 value: \";\ncin &gt;&gt; y2;\ncout &lt;&lt; endl;\ncout &lt;&lt; \"Passing x1 &amp; y1 by value: (Z = 10*X + 20*Y)\" &lt;&lt; endl;\ncout &lt;&lt; \"Z = \" &lt;&lt; FuncVal(x1, y1) &lt;&lt; endl &lt;&lt; endl;\ncout &lt;&lt; \"x1 &amp; y1 values after passing them by value: \" &lt;&lt; endl;\ncout &lt;&lt; \"x1 = \" &lt;&lt; x1 &lt;&lt; \"     \" &lt;&lt; \"y1 = \" &lt;&lt; y1 &lt;&lt; endl;\ncout &lt;&lt; \"----------------------------------------------------\" &lt;&lt; endl;\ncout &lt;&lt; \"Passing x2 &amp; y2 by reference: (Z = 10*X + 20*Y)\" &lt;&lt; endl;\ncout &lt;&lt; \"Z = \" &lt;&lt; FuncRef(&amp;x2, &amp;y2) &lt;&lt; endl &lt;&lt; endl;\ncout &lt;&lt; \"x2 &amp; y2 values after passing them by reference: \" &lt;&lt; endl;\ncout &lt;&lt; \"x2 = \" &lt;&lt; x2 &lt;&lt; \"     \" &lt;&lt; \"y2 = \" &lt;&lt; y2 &lt;&lt; endl;\ncout &lt;&lt; \"----------------------------------------------------\" &lt;&lt; endl;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>Enter x1 value: 1\n\nEnter y1 value: 1\n\nEnter x2 value: 1\n\nEnter y2 value: 1\n\nPassing x1 &amp; y1 by value: (Z = 10*X + 20*Y)\nZ = 30\n\nx1 &amp; y1 values after passing them by value: \nx1 = 1     y1 = 1\n----------------------------------------------------\nPassing x2 &amp; y2 by reference: (Z = 10*X + 20*Y)\nZ = 30\n\nx2 &amp; y2 values after passing them by reference: \nx2 = 10     y2 = 20\n----------------------------------------------------\n</code></pre> <p>In this code:</p> <ul> <li>There are two functions, <code>FuncVal</code> and <code>FuncRef</code>, that perform the same mathematical operation <code>(Z = 10X + 20Y)</code>.</li> <li>The only difference between them is how they receive their parameters.</li> <li><code>FuncVal</code> receives it parameters by value, which means that it receives a copy of the original values and any changes made to the parameters in the function won't affect the original values outside the function.</li> <li><code>FuncRef</code> receives its parameters by reference, meaning it operates on the original values, so any changes made to the parameters in the function will affect the original values outside the function.</li> <li>In the <code>main</code> function, the user inputs 4 values, <code>x1</code>, <code>y1</code>, <code>x2</code>, and <code>y2</code>.</li> <li>Then, the program calculates the value of <code>z</code> using both functions, <code>FuncVal</code> and <code>FuncRef</code>, and prints the results along with the values of <code>x1</code>, <code>y1</code>, <code>x2</code> and <code>y2</code> after passing them to the functions.</li> <li>This demonstrates the difference between passing by value and passing by reference.</li> </ul>"},{"location":"cpp_switch_statement/","title":"C++ Switch Statement","text":""},{"location":"cpp_switch_statement/#introduction","title":"Introduction","text":"<p>In C++, the <code>switch...case</code> statement is used to perform different actions base on the value of a single expression.</p>"},{"location":"cpp_switch_statement/#cpp-switchcase-statement","title":"cpp switch...case Statement","text":"<p>Syntax:</p> <pre><code>switch (expression) {\ncase constant1:\n/* code to be executed if\n        expression is equal to constant1; */\nbreak;\ncase constant2:\n/* code to be executed if\n        expression is equal to constant2 */\nbreak;\ndefault:\n/* code to be executed if\n        expression doesn't match any constant */\n}\n</code></pre> <p>The <code>expression</code> is evaluated and compared to the values specified in each <code>case</code> statement.  - If a match is found, the corresponding code block is executed. - If no match is found, the code in the <code>default</code> block is executed.</p> <p>Notice that the <code>break</code> statement is used inside each <code>case</code> block. This terminates the <code>switch</code> statement.</p> <p>If the <code>break</code> statement is not used, all cases after the correct <code>case</code> will be executed, which is NOT what we want!</p>"},{"location":"cpp_switch_statement/#flowchart-of-switchcase-statement","title":"Flowchart of switch...case Statement","text":"<p> Switch...case Statement Flowchart</p> <p>Note: The expression used in the switch statement can be of type <code>int</code>, <code>char</code>, <code>enum</code> and <code>string</code> (c++17 and later) and the case label can be constant expressions like integer, character and enumeration.</p> <p>Example 1.4.1:</p> <pre><code>#include &lt;iostream&gt;\nint main(){\nint x = 2;\nswitch (x) {\ncase 1:\nstd::cout &lt;&lt; \"x is 1\" &lt;&lt; std::endl;\nbreak;\ncase 2:\nstd::cout &lt;&lt; \"x is 2\" &lt;&lt; std::endl;\nbreak;\ncase 3:\nstd::cout &lt;&lt; \"x is 3\" &lt;&lt; std::endl;\nbreak;\ndefault:\nstd::cout &lt;&lt; \"x is not 1, 2, or 3\" &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>x is 2\n</code></pre> <p>In this code:</p> <ul> <li>The variable <code>x</code> is assigned the value of <code>2</code>.</li> <li>Then, the <code>switch</code> statement is used to check the value of <code>x</code>.</li> <li>The <code>switch</code> statement checks for a match between the value of <code>x</code> and the cases inside the switch statement.</li> <li>When a match is found, the corresponding code block is executed.</li> </ul> <p>The <code>switch</code> statement is useful when you have a single expression that can have multiple possible values, and you want to perform different actions based on the value of that expression. It's an alternative to multiple <code>if...else</code> statements, and it can make your code more readable and efficient.</p>"},{"location":"cpp_while_loop/","title":"C++ while Loop","text":""},{"location":"cpp_while_loop/#introduction","title":"Introduction","text":"<p>The <code>while</code> loop in C++ repeatedly executes a block of code as long as the specified condition is <code>true</code>.</p>"},{"location":"cpp_while_loop/#cpp-while-loop","title":"cpp while Loop","text":"<p>Syntax:</p> <pre><code>while (condition) {\n// statement\n}\n</code></pre> <p>Here:</p> <ul> <li>A <code>while</code> loop evaluates the <code>condition</code>.</li> <li>If the <code>condition</code> is <code>true</code>, the code inside the <code>while</code> loop is executed.</li> <li>The <code>condition</code> is evaluated again.</li> <li>This process continues until the <code>condition</code> is <code>false</code>.</li> <li>When the <code>condition</code> evaluates to <code>false</code>, the loop terminates.</li> </ul> <p> while Loop Statement Flowchart</p> <p>Example 1.7.1:</p> <pre><code>#include &lt;iostream&gt;\nint main() {\nint count = 1;\nwhile (count &lt;= 5) {\nstd::cout &lt;&lt; count &lt;&lt; \" \";\ncount++;\n}\nstd::cout &lt;&lt; std::endl;\nreturn 0;   }\n</code></pre> <p>Output:</p> <pre><code>1 2 3 4 5\n</code></pre> <p>In this code:</p> <ul> <li>The <code>while</code> loop continues to execute as long as <code>count</code> is less than or equal to <code>5</code>.</li> <li>The variable <code>count</code> is incremented inside the loop so that eventually the condition becomes false and the loop terminates.</li> </ul>"},{"location":"cpp_while_loop/#cpp-dowhile-loop","title":"cpp do...while Loop","text":"<p>The <code>do...while</code> loop in C++ is similar to the <code>while</code> loop, but with one important difference: the block of code in a <code>do...while</code> loop is guaranteed to execute at least once.</p> <p>Syntax:</p> <pre><code>do {\n//statement\n} while (condition);\n</code></pre> <p>Here:</p> <ul> <li>The body of the loop is executed at first. Then the <code>condition</code> is evaluated.</li> <li>If the <code>condition</code> evaluates to <code>true</code>, the body of the loop inside the <code>do</code> statement is executed again.</li> <li>The <code>condition</code> is evaluated once again.</li> <li>If the <code>condition</code> evaluates to <code>true</code>, the body of the loop inside the <code>do</code> statement is executed again.</li> <li>This process continues until the <code>condition</code> evaluates to <code>false</code>. Then the loop stops.</li> </ul> <p> do...while Loop Statement Flowchart</p> <p>Example 1.7.2:</p> <pre><code>#include &lt;iostream&gt;\nint main() {\nint count = 1;\ndo {\nstd::cout &lt;&lt; count &lt;&lt; \" \";\ncount++;\n} while (count &lt;= 5);\nstd::cout &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>1 2 3 4 5\n</code></pre> <p>In this code:</p> <ul> <li>The <code>do...while</code> loop will first execute the block of code inside the loop.</li> <li>Then it evaluates the condition.<ul> <li>If the condition is true, the loop will repeat.</li> <li>If the condition is false, the loop will terminate.</li> </ul> </li> </ul>"},{"location":"dsa_p1/","title":"Pattern 1","text":""},{"location":"dsa_p1/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5,m=5;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;m;j++) {\nstd::cout &lt;&lt; \"*\";\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>*****\n*****\n*****\n*****\n*****\n</code></pre> <p>In this code:</p> <ul> <li>The first line of the code sets the values of two integer variables <code>n</code> and <code>m</code> to <code>5</code> (where <code>n</code> represents the number of rows and <code>m</code> represents the number of columns).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from <code>0</code> to <code>n-1</code> (<code>0</code> to <code>4</code>), and the inner loop <code>j</code> runs from <code>0</code> to <code>m-1</code> (<code>0</code> to <code>4</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; \"*\";</code> prints an asterisk to the console.</li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> <li>This process repeats until both loops have finished executing, and a grid of asterisks <code>5</code> rows tall and <code>5</code> columns wide is printed to the console.</li> </ul>"},{"location":"dsa_p10/","title":"Pattern 10","text":""},{"location":"dsa_p10/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;=i;j++) {\nstd::cout &lt;&lt; \"*\";\n}\nstd::cout &lt;&lt; std::endl;\n}\nfor(int i=n-1;i&gt;=1;i--) {\nfor(int j=1;j&lt;=i;j++) {\nstd::cout &lt;&lt; \"*\";\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>*\n**\n***\n****\n*****\n****\n***\n**\n*\n</code></pre> <p>In this code:</p> <ul> <li>We need to print two mirrored right-triangle patterns of height <code>n</code>.</li> <li>The first half of the code (the first loop) creates the upper half of the right-triangle pattern, where the number of asterisks increases in each row until it reaches the maximum value of <code>n</code>:<ul> <li>The outer loop <code>i</code> runs from (<code>0</code> to <code>n-1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from <code>0</code> to <code>i</code> (<code>0</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; \"*\";</code> prints an asterisk to the console.<ul> <li>when the algorithm is running in row <code>i=2</code> the inner loop will print <code>2</code> asterisks.</li> <li>when it runs in row <code>i=3</code> the inner loop will print <code>3</code> asterisks.</li> </ul> </li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> </ul> </li> <li>The second half of the code (the second loop) creates the lower half of the right-triangle pattern, where the number of asterisks decreases in each row until it reaches <code>1</code>:<ul> <li>The outer loop <code>i</code> runs from (<code>n-1</code> to <code>1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>1</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; \"*\";</code> prints an asterisk to the console.<ul> <li>when the algorithm is running in row <code>i=2</code> the inner loop will print <code>4</code> asterisks.</li> <li>when it runs in row <code>i=3</code> the inner loop will print <code>3</code> asterisks, and so on.</li> </ul> </li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> </ul> </li> <li>In the end, we will get two mirrored right-triangle pattern printed to the console.</li> </ul>"},{"location":"dsa_p11/","title":"Pattern 11","text":""},{"location":"dsa_p11/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;=i;j++) {\nstd::cout &lt;&lt; ((i+j+1))%2;\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>1\n01\n101\n0101\n10101\n</code></pre> <p>In this code:</p> <ul> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the right-triangle height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>0</code> to <code>n-1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>0</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>The expression <code>((i + j + 1)) % 2</code> is used to determine the value to be printed in each position of the pattern<ul> <li>The expression <code>i + j + 1</code> returns the sum of the row number <code>i</code> and the column number <code>j</code>, plus <code>1</code>.</li> <li>The result is then taken modulo <code>2</code>, which results in either <code>0</code> or <code>1</code>.</li> </ul> </li> <li>For each iteration of the inner loop, the value of <code>((i + j + 1)) % 2</code> is printed to the console.</li> <li>After each inner loop finishes, a new line is printed to the console with <code>std::cout &lt;&lt; std::endl;</code>.</li> </ul>"},{"location":"dsa_p12/","title":"Pattern 12","text":""},{"location":"dsa_p12/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=4;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;n;j++) {\nif(j&lt;=i) {\nstd::cout &lt;&lt; j+1;\n}\nelse {\nstd::cout &lt;&lt; \" \";\n}\n}\nfor(int j=n-1;j&gt;=0;j--) {\nif(j&lt;=i) {\nstd::cout &lt;&lt; j+1;\n}\nelse {\nstd::cout &lt;&lt; \" \";\n}\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>1      1\n12    21\n123  321\n12344321\n</code></pre> <p>In this code:</p> <ul> <li>This is a pattern of two triangles, with one being a right-triangle and the other being a mirror image (a left-triangle). The spaces are used to maintain the triangle shape, making the pattern symmetrical.</li> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the number of rows for the two triangles).</li> <li>In the <code>main</code> function, we have a <code>for</code> loop that runs <code>n</code> times. For each iteration of this loop, the following happens:<ul> <li>We have an inner <code>for</code> loop that runs <code>n</code> times. This loop is used to print the first triangle.<ul> <li>Within this inner loop, there is an <code>if</code> statement that checks if the value of <code>j</code> is less than or equal to <code>i</code>.</li> <li>If it is, the value of <code>j+1</code> is printed.</li> <li>If not, a space character <code>\" \"</code> is printed.</li> </ul> </li> <li>The second <code>for</code> inner loop runs <code>n</code> times in reverse order. This loop is used to print the second triangle.<ul> <li>Within this inner loop, there is an <code>if</code> statement that checks if the value of <code>j</code> is less than or equal to <code>i</code>.</li> <li>If it is, the value of <code>j+1</code> is printed.</li> <li>If not, a space character <code>\" \"</code> is printed.</li> </ul> </li> <li>Finally, after the second inner loop, a newline character <code>std::endl</code> is printed to move to the next row.</li> </ul> </li> <li>The loop continues to run until all <code>n</code> iterations are completed.</li> </ul>"},{"location":"dsa_p13/","title":"Pattern 13","text":""},{"location":"dsa_p13/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5, cnt=1;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;=i;j++) {\nstd::cout &lt;&lt; cnt++ &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>1 \n2 3 \n4 5 6 \n7 8 9 10 \n11 12 13 14 15 \n</code></pre> <p>In this code:</p> <ul> <li>First, we define two integers <code>n</code> and <code>cnt</code>, with values <code>5</code> and <code>1</code> respectively. <code>n</code> will be used to control the number of rows for the two triangles and <code>cnt</code> is a counter variable that will be used to print the numbers in the triangle pattern.</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>0</code> to <code>n-1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>0</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>The code <code>std::cout &lt;&lt; cnt++ &lt;&lt; \" \";</code> prints the value of <code>cnt</code> and then increments <code>cnt</code> by <code>1</code>. This will print the numbers in ascending order in the triangle pattern.</li> <li>After that, the code <code>std::cout &lt;&lt; std::endl;</code> is executed to print a newline character and move to the next row of the triangle pattern.</li> <li>The loop continues to run until all <code>n</code> iterations are completed.</li> </ul>"},{"location":"dsa_p14/","title":"Pattern 14","text":""},{"location":"dsa_p14/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;=i;j++) {\nstd::cout &lt;&lt; (char)('A' + j);\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>A\nAB\nABC\nABCD\nABCDE\n</code></pre> <p>In this code:</p> <ul> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the right-triangle height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>0</code> to <code>n-1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>0</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; (char)('A' + j);</code> prints an ASCII code of the character that corresponds to <code>j</code>, and the <code>(char)</code> typecast converts the result to a character.<ul> <li>when the algorithm is running in the second row <code>i=2</code>, we need to print the character <code>'A'+j</code> that corresponds to the column number to the console <code>AB</code>.</li> <li>when the algorithm is running in the third row <code>i=3</code>, we need to print the character <code>'A'+j</code> that corresponds to the column number to the console <code>ABC</code>.</li> </ul> </li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> <li>This process repeats until both loops have finished executing, and a right triangle pattern of <code>5</code> rows tall using characters from the alphabet is printed to the console.</li> </ul>"},{"location":"dsa_p15/","title":"Pattern 15","text":""},{"location":"dsa_p15/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=n;i&gt;=1;i--) {\nfor(int j=1;j&lt;=i;j++) {\nstd::cout &lt;&lt; (char)('A' + j - 1);\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>ABCDE\nABCD\nABC\nAB\nA\n</code></pre> <p>In this code:</p> <ul> <li>We need to print a right-triangle pattern using characters from the alphabet, but with the rows starting from the highest value of <code>n</code> (number of rows) and decrementing down to <code>1</code>.</li> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the right-triangle height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>n</code> to <code>1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>1</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; (char)('A' + j);</code> prints an ASCII code of the character that corresponds to <code>j</code>, and the <code>(char)</code> typecast converts the result to a character.<ul> <li>when the algorithm is running in the second row <code>i=4</code>, we need to print the character <code>'A'+j</code> that corresponds to the column number to the console <code>ABCD</code>.</li> <li>when the algorithm is running in the third row <code>i=3</code>, we need to print the character <code>'A'+j</code> that corresponds to the column number to the console <code>ABC</code>.</li> </ul> </li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> <li>This process repeats until both loops have finished executing, and a right-triangle pattern of <code>5</code> rows tall using characters from the alphabet is printed to the console, the rows starts from the highest value of <code>n = 5</code> and decrements down to <code>1</code>.</li> </ul>"},{"location":"dsa_p16/","title":"Pattern 16","text":""},{"location":"dsa_p16/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5,m=5;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;=i;j++) {\nstd::cout &lt;&lt; (char)('A' + i);\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>A\nBB\nCCC\nDDDD\nEEEEE\n</code></pre> <p>In this code:</p> <ul> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the right-triangle height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>0</code> to <code>n-1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>0</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; (char)('A' + i);</code> prints an ASCII code of the character that corresponds to <code>i</code>, and the <code>(char)</code> typecast converts the result to a character.<ul> <li>when the algorithm is running in the second row <code>i=2</code>, we need to print  <code>'A'+i=B</code>, <code>i</code> time to the console <code>BB</code>.</li> <li>when the algorithm is running in the third row <code>i=3</code>, we need to print <code>'A'+i=C</code>, <code>i</code> time to the console <code>CCC</code>.</li> </ul> </li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> <li>This process repeats until both loops have finished executing, and a right-triangle pattern of numbers <code>1</code> to <code>5</code> is printed to the console.</li> </ul>"},{"location":"dsa_p17/","title":"Pattern 17","text":""},{"location":"dsa_p17/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=4,m=7;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;(m-2*i-1)/2;j++) {\nstd::cout &lt;&lt; \" \";\n}\nfor(int j=0;j&lt;i+1;j++) {\nstd::cout &lt;&lt; (char)('A' + j);\n}\nfor(int j=i;j&gt;0;j--) {\nstd::cout &lt;&lt; (char)('A' + j-1);\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>   A\n  ABA\n ABCBA\nABCDCBA\n</code></pre> <p>In this code:</p> <ul> <li>First, we define two variables <code>n</code> and <code>m</code>, with the values <code>4</code> and <code>7</code> respectively.<ul> <li><code>n</code> is used to control the number of rows in the pyramid shape.</li> <li><code>m</code> is used to determine the width of each row.</li> </ul> </li> <li>In the <code>main</code> function, we have a <code>for</code> loop <code>i</code> runs from (<code>0</code> to <code>n-1</code>), this will handle the height of the pattern.<ul> <li>Inside, we have the first inner loop <code>j</code> runs from (<code>0</code> to <code>(m-2*i-1)/2</code>) that will print spaces <code>\" \"</code> before the letters in each row.<ul> <li>The number of spaces printed will be determined by the expression <code>(m-2*i-1)/2</code>, which calculates the number of spaces required for each row.</li> </ul> </li> <li>After printing the spaces, another for loop <code>j</code> runs from (<code>0</code> to <code>i+1</code>) is used to print the letters, where <code>j</code> is the current letter.<ul> <li>The letters will start from <code>'A'</code> and increase by one for each subsequent letter in the same row.</li> </ul> </li> <li>Finally, another for loop <code>j</code> runs from (<code>i</code> to <code>1</code>) is used to print the decreasing letters, which form the right half of the pyramid shape.<ul> <li>The letters will start from the last letter in the previous loop and decrease by one for each subsequent letter in the same row.</li> </ul> </li> </ul> </li> <li>The loop continues to run until all <code>n</code> iterations are completed.</li> </ul>"},{"location":"dsa_p2/","title":"Pattern 2","text":""},{"location":"dsa_p2/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;=i;j++) {\nstd::cout &lt;&lt; \"*\";\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>*\n**\n***\n****\n*****\n</code></pre> <p>In this code:</p> <ul> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the right-triangle height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>0</code> to <code>n-1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>0</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; \"*\";</code> prints an asterisk to the console.<ul> <li>when the algorithm is running in row <code>i=2</code> the inner loop will print <code>2</code> asterisks.</li> <li>when it runs in row <code>i=3</code> the inner loop will print <code>3</code> asterisks.</li> </ul> </li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> <li>This process repeats until both loops have finished executing, and a right triangle pattern of asterisks <code>5</code> rows tall is printed to the console.</li> </ul>"},{"location":"dsa_p3/","title":"Pattern 3","text":""},{"location":"dsa_p3/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;=i;j++) {\nstd::cout &lt;&lt; j+1;\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>1\n12\n123\n1234\n12345\n</code></pre> <p>In this code:</p> <ul> <li>Like the previous program, this one also prints a right-triangle pattern, but instead of asterisks (<code>*</code>), it prints numbers.</li> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the right-triangle height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>0</code> to <code>n-1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>0</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; j+1;</code> prints the value of <code>j+1</code> to the console (the number of column).<ul> <li>when the algorithm is running in the second row <code>i=2</code>, we need to print the number of the first and second columns to the console <code>1 2</code>.</li> <li>when the algorithm is running in the third row <code>i=3</code>, we need to print the number of the first <code>3</code> columns to the console <code>1 2 3</code>.</li> </ul> </li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> <li>This process repeats until both loops have finished executing, and a right-triangle pattern of numbers <code>1</code> to <code>5</code> is printed to the console.</li> </ul>"},{"location":"dsa_p4/","title":"Pattern 4","text":""},{"location":"dsa_p4/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=0;i&lt;n;i++) {\nfor(int j=0;j&lt;=i;j++) {\nstd::cout &lt;&lt; i+1;\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>1\n22\n333\n4444\n55555\n</code></pre> <p>In this code:</p> <ul> <li>Like the previous two programs, this one also prints a right-triangle pattern, but instead of asterisks (<code>*</code>) or numbers, it prints the current value of the outer loop variable <code>i+1</code>.</li> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the right-triangle height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>0</code> to <code>n-1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>0</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; i+1;</code> prints the value of <code>i+1</code> to the console (the number of the current row we are in).<ul> <li>when the algorithm is running in the second row <code>i=2</code>, we need to print the number of the row, <code>i+1=2</code> time to the console <code>2 2</code>.</li> <li>when the algorithm is running in the third row <code>i=3</code>, we need to print the number of the row, <code>i+1=3</code> time to the console <code>3 3 3</code>.</li> </ul> </li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> <li>This process repeats until both loops have finished executing, and a right-triangle pattern of numbers <code>1</code> to <code>5</code> is printed to the console.</li> </ul>"},{"location":"dsa_p5/","title":"Pattern 5","text":""},{"location":"dsa_p5/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=n;i&gt;=1;i--) {\nfor(int j=1;j&lt;=i;j++) {\nstd::cout &lt;&lt; \"*\";\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>*****\n****\n***\n**\n*\n</code></pre> <p>In this code:</p> <ul> <li>We need to print a right-triangle pattern of asterisks (<code>*</code>), but with the rows starting from the highest value of <code>n</code> (number of rows) and decrementing down to <code>1</code>.</li> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the right-triangle height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>n</code> to <code>1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>1</code> to <code>i</code>) for each iteration of the outer loop.<ul> <li>we start counting backwards, the first line value is <code>5</code>. so, we need to print the asterisks sign five times.</li> <li>the second line value is <code>4</code>. so, we print the asterisks sign four times, and so on.</li> </ul> </li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> <li>This process repeats until both loops have finished executing, and a right-triangle pattern of asterisks is printed to the console with the rows starting from the highest value of <code>n</code> (5) and decrementing down to <code>1</code>.</li> </ul>"},{"location":"dsa_p6/","title":"Pattern 6","text":""},{"location":"dsa_p6/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=n;i&gt;=1;i--) {\nfor(int j=1;j&lt;=i;j++) {\nstd::cout &lt;&lt; j;\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>12345\n1234\n123\n12\n1\n</code></pre> <p>In this code:</p> <ul> <li>Like the previous program, this one also prints a right-triangle pattern, but instead of asterisks (<code>*</code>), it prints numbers.</li> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the right-triangle height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>n</code> to <code>1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>1</code> to <code>i</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; j;</code> prints the value of <code>j</code> to the console (the number of column).<ul> <li>when the algorithm is running in the second row <code>i=4</code>, we need to print the value of the first <code>4</code> columns to the console <code>1 2 3 4</code>.</li> <li>when the algorithm is running in the third row <code>i=3</code>, we need to print the number of the first <code>3</code> columns to the console <code>1 2 3</code>.</li> </ul> </li> <li>After the inner loop finishes executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> <li>This process repeats until both loops have finished executing, and a right-triangle pattern of asterisks is printed to the console with the rows starting from the highest value of <code>n</code> (5) and decrementing down to <code>1</code>.</li> </ul>"},{"location":"dsa_p7/","title":"Pattern 7","text":""},{"location":"dsa_p7/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=1;i&lt;=n;i++) {\nfor(int j=1;j&lt;=n-i;j++) {\nstd::cout &lt;&lt; \" \";\n}\nfor(int j=0;j&lt;2*i - 1;j++) {\nstd::cout&lt;&lt;\"*\";\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>    *\n   ***\n  *****\n *******\n*********\n</code></pre> <p>In this code:</p> <ul> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the pyramid height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>1</code> to <code>n</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>1</code> to <code>n-1</code>) for each iteration of the outer loop.</li> <li>Inside the inner loop, the statement <code>std::cout &lt;&lt; \" \";</code> prints a space character to the console. The number of spaces printed depends on the value of <code>n</code> and the current iteration of the outer loop.<ul> <li>when the algorithm is running in the first row <code>i=1</code> the number of white-spaces <code>\" \"</code> is <code>n-i=4</code>, this sets the center of the pyramid 4 places to the right in order to give the pyramid its shape on the console.</li> <li>when the algorithm is running in the second row <code>i=2</code> the number of white-spaces <code>\" \"</code> is <code>n-i=3</code>, and so on.</li> </ul> </li> <li>The second inner loop <code>j</code> runs from <code>0</code> to <code>2*i-1</code> for each iteration of the outer loop.<ul> <li>when the algorithm is running in the first row <code>i=1</code> the number of asterisks that we need to print is <code>2*i-1=1</code>, this will print the pointed head of the pyramid.</li> <li>when the algorithm is running in the second row <code>i=2</code> the number of asterisks that we need to print is <code>2*i-1=3</code>, this will reprint the center line and adds two more (one on the right and one on the left, thus giving the illusion of printing a pyramid), and so on.</li> </ul> </li> <li>After the inner loops finish executing, the statement <code>std::cout &lt;&lt; std::endl;</code> prints a newline character, which causes the program to print a new line for the next iteration of the outer loop.</li> <li>This process repeats until both loops have finished executing, and pyramid pattern of asterisks (<code>*</code>) with the height of <code>n</code> is printed to the console.</li> </ul>"},{"location":"dsa_p8/","title":"Pattern 8","text":""},{"location":"dsa_p8/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=n;i&gt;=1;i--) {\nfor(int j=1;j&lt;=n-i;j++) {\nstd::cout &lt;&lt; \" \";\n}\nfor(int j=0;j&lt;2*i - 1;j++) {\nstd::cout &lt;&lt; \"*\";\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>*********\n *******\n  *****\n   ***\n    *\n</code></pre> <p>In this code:</p> <ul> <li>The first line of code sets the value of an integer variable <code>n</code> to <code>5</code> (where <code>n</code> is the pyramid height or the number of rows).</li> <li>In the <code>main</code> function, there are two nested <code>for</code> loops. The outer loop <code>i</code> runs from (<code>n</code> to <code>1</code>), this will handle the height of the pattern, and the inner loop <code>j</code> runs from (<code>1</code> to <code>n-i</code>) for each iteration of the outer loop.<ul> <li>This loop is used to print the white-space characters <code>\" \"</code> to indent the asterisks to the right.</li> <li>The number of white-spaces printed in each row is calculated using the expression <code>n-i</code>.</li> <li>For example, when the algorithm is running in the third row <code>i=3</code> the number of white-spaces is <code>n-i=2</code>.</li> </ul> </li> <li>After printing the white spaces, another nested loop runs <code>2*i-1</code> number of times to print the asterisk <code>*</code> to form the pyramid shape</li> <li>The number of asterisks printed in each row is calculated using the expression <code>2*i-1</code>.<ul> <li>For example, when the algorithm is running in the first row <code>i=5</code>, the number of asterisks that we need to print is <code>2*i-1=9</code>.</li> <li>when the algorithm is running in the second row <code>i=4</code>, the number of asterisks that we need to print is <code>2*i-1=7</code>, and so on.</li> </ul> </li> <li>After the inner loops are finished, a call to <code>std::cout &lt;&lt; std::endl;</code> is made to move the cursor to the next line in the console, thus allowing the next row of the pyramid to be printed on a new line.</li> <li>The outer loop continues to run <code>n</code> number of times until <code>i</code> is equal to <code>1</code>.</li> </ul>"},{"location":"dsa_p9/","title":"Pattern 9","text":""},{"location":"dsa_p9/#solution","title":"Solution","text":"<pre><code>#include &lt;iostream&gt;\nint n=5;\nint main(){\nfor(int i=1;i&lt;=n;i++) {\nfor(int j=1;j&lt;=n-i;j++) {\nstd::cout &lt;&lt; \" \";\n}\nfor(int j=0;j&lt;2*i - 1;j++) {\nstd::cout &lt;&lt; \"*\";\n}\nstd::cout &lt;&lt; std::endl;\n}\nfor(int i=n;i&gt;=1;i--) {\nfor(int j=1;j&lt;=n-i;j++) {\nstd::cout &lt;&lt; \" \";\n}\nfor(int j=0;j&lt;2*i - 1;j++) {\nstd::cout &lt;&lt; \"*\";\n}\nstd::cout &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>    *\n   ***\n  *****\n *******\n*********\n*********\n *******\n  *****\n   ***\n    *\n</code></pre> <p>In this code:</p> <ul> <li>We need to print two mirrored pyramid patterns of height <code>n</code>.</li> <li>The first half of the code (the first loop) creates the upper half of the pyramid pattern:<ul> <li>The outer loop <code>i</code> runs from (<code>1</code> to <code>n</code>), this will handle the height of the pattern.</li> <li>The first inner loop <code>j</code>  runs from (<code>1</code> to <code>n-i</code> ) creates the necessary white-spaces before each row of asterisks to maintain the pyramid shape.<ul> <li>The number of white-spaces decreases by <code>1</code> after each iteration of the outer loop.</li> </ul> </li> <li>The second inner loop <code>j</code> runs from (<code>0</code> to <code>2*i-1</code>) creates the actual row of asterisks.<ul> <li>The number of asterisks in each row increases by <code>2</code> after each iteration of the outer loop.</li> </ul> </li> </ul> </li> <li>The second half of the code (the second loop) creates the bottom half of the pyramid pattern, which is simply a mirror image of the upper half:<ul> <li>The outer loop <code>i</code> runs from (<code>n</code> to <code>1</code>), this will handle the height of the pattern.</li> <li>The first inner loop <code>j</code>  runs from (<code>1</code> to <code>n-i</code> ) creates the necessary white-spaces before each row of asterisks to maintain the pyramid shape.<ul> <li>The number of white-spaces decreases by <code>1</code> after each iteration of the outer loop.</li> </ul> </li> <li>The second inner loop <code>j</code> runs from (<code>0</code> to <code>2*i-1</code>) creates the actual row of asterisks.<ul> <li>The number of asterisks in each row increases by <code>2</code> after each iteration of the outer loop.</li> </ul> </li> </ul> </li> <li>In the end, the two mirrored pyramid patterns are displayed on the console.</li> </ul>"},{"location":"time_complexity/","title":"Time Complexity","text":""},{"location":"time_complexity/#introduction","title":"Introduction","text":"<p>In computer science, time complexity is a fundamental concept that measures the amount of time an algorithm takes to run as a function of the size of its input data.</p> <p>This is an important aspect of algorithm design and analysis, as it helps us determine the efficiency of different algorithms and choose the best one for a particular problem. Understanding time complexity is key to creating efficient and scalable software systems.</p> <p>Time complexity is often expressed using <code>Big O Notation</code>, which provides an upper bound on the growth of the running time as the size of the input data increases. The notation describes the rate at which the running time grows relative to the size of the input. For example, if an algorithm has a time complexity of <code>O(n)</code>, it means that its running time is proportional to the size of the input data.</p>"},{"location":"time_complexity/#the-constant-time-complexity","title":"The Constant Time Complexity","text":"<p>Symbol: <code>O(1)</code></p> <p>The running time does not depend on the size of the input data and remains constant, regardless of how large the input is.</p> <p> Constant Time Complexity Flowchart</p> <p>Common Uses:</p> <ul> <li>Accessing an element in an array using an index.</li> <li>Retrieving the value of a constant or a simple mathematical expression.</li> <li>Checking if a number is odd or even.</li> </ul>"},{"location":"time_complexity/#the-logarithmic-time-complexity","title":"The Logarithmic Time Complexity","text":"<p>Symbol: <code>O(log(n))</code></p> <p>The running time grows logarithmic-ally with the size of the input data. This is often the case for algorithms that divide the input data in half at each step.</p> <p> Logarithmic Time Complexity Flowchart</p> <p>Common Uses:</p> <ul> <li>Binary Search in a sorted array.</li> <li>Finding the lower bound of an element in a sorted array using binary search.</li> <li>Performing operations on binary trees.</li> </ul>"},{"location":"time_complexity/#the-linear-time-complexity","title":"The Linear Time Complexity","text":"<p>Symbol: <code>O(n)</code></p> <p>The running time grows linearly with the size of the input data. This is often the case for algorithms that process each item in the input data once.</p> <p> Linear Time Complexity Flowchart</p> <p>Common Uses:</p> <ul> <li>Iterating through an array and performing an operation on each element.</li> <li>Finding the maximum or minimum value in an array.</li> <li>Sequentially searching for an element in an unsorted array.</li> </ul>"},{"location":"time_complexity/#the-log-linear-time-complexity","title":"The Log-linear Time Complexity","text":"<p>Symbol: <code>O(n*log(n))</code></p> <p>The running time grows at a rate that is between linear and logarithmic. This is often the case for algorithms that divide the input data in half and process each item once, such as the merge sort algorithm.</p> <p> Log-linear Time Complexity Flowchart</p> <p>Common Uses:</p> <ul> <li>Sorting algorithms like Merge Sort, Quick Sort.</li> <li>Finding the closest pair of points in a set of points.</li> <li>Finding the longest increasing sub-sequence in a sequence.</li> </ul>"},{"location":"time_complexity/#the-quadratic-time-complexity","title":"The Quadratic Time Complexity","text":"<p>Symbol: <code>O(n^2)</code></p> <p>The running time grows at a rate that is proportional to the square of the size of the input data. This is often the case for algorithms that compare each item in the input data with every other item.</p> <p> Quadratic Time Complexity Flowchart</p> <p>Common Uses:</p> <ul> <li>Simple sorting algorithms like Bubble Sort, Insertion Sort.</li> <li>Checking all possible combinations of pairs in an array.</li> <li>Finding all sub-arrays in an array.</li> </ul>"},{"location":"time_complexity/#the-exponential-time-complexity","title":"The Exponential Time Complexity","text":"<p>Symbol: <code>O(2^n)</code></p> <p>The running time grows at a rate that is proportional to two raised to the power of the size of the input data. This is often the case for algorithms that solve problems by considering all possible combinations of items.</p> <p> Exponential Time Complexity Flowchart</p> <p>Common Uses:</p> <ul> <li>Generating all subsets of a set.</li> <li>Solving the traveling salesman problem.</li> <li>Finding all possible solutions to the n-queens problem.</li> </ul>"},{"location":"time_complexity/#the-factorial-time-complexity","title":"The Factorial Time Complexity","text":"<p>Symbol: <code>O(n!)</code></p> <p> Factorial Time Complexity Flowchart</p> <p>Common Uses:</p> <ul> <li>Generating all permutations of a set.</li> <li>Solving the n-puzzle problem.</li> <li>Calculating the number of possible Hamiltonian cycles in a graph.</li> </ul>"},{"location":"time_complexity/#summary","title":"Summary","text":"<p>Time complexity is an essential concept in computer science that helps us determine the efficiency of algorithms and choose the best one for a particular problem. By understanding time complexity and its various forms, we can design algorithms that are both efficient and scalable, which is crucial for creating successful software systems.</p> <p> Full Time Complexity Flowchart</p>"}]}